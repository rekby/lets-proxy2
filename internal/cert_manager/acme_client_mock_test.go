package cert_manager

// Code generated by http://github.com/gojuno/minimock (3.0.6). DO NOT EDIT.

//go:generate minimock -i github.com/rekby/lets-proxy2/internal/cert_manager.AcmeClient -o ./acme_client_mock_test.go

import (
	"context"
	"crypto/tls"
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gojuno/minimock/v3"
	"golang.org/x/crypto/acme"
)

// AcmeClientMock implements AcmeClient
type AcmeClientMock struct {
	t minimock.Tester

	funcAccept          func(ctx context.Context, chal *acme.Challenge) (cp1 *acme.Challenge, err error)
	inspectFuncAccept   func(ctx context.Context, chal *acme.Challenge)
	afterAcceptCounter  uint64
	beforeAcceptCounter uint64
	AcceptMock          mAcmeClientMockAccept

	funcAuthorizeOrder          func(ctx context.Context, id []acme.AuthzID, opt ...acme.OrderOption) (op1 *acme.Order, err error)
	inspectFuncAuthorizeOrder   func(ctx context.Context, id []acme.AuthzID, opt ...acme.OrderOption)
	afterAuthorizeOrderCounter  uint64
	beforeAuthorizeOrderCounter uint64
	AuthorizeOrderMock          mAcmeClientMockAuthorizeOrder

	funcCreateOrderCert          func(ctx context.Context, url string, csr []byte, bundle bool) (der [][]byte, certURL string, err error)
	inspectFuncCreateOrderCert   func(ctx context.Context, url string, csr []byte, bundle bool)
	afterCreateOrderCertCounter  uint64
	beforeCreateOrderCertCounter uint64
	CreateOrderCertMock          mAcmeClientMockCreateOrderCert

	funcGetAuthorization          func(ctx context.Context, url string) (ap1 *acme.Authorization, err error)
	inspectFuncGetAuthorization   func(ctx context.Context, url string)
	afterGetAuthorizationCounter  uint64
	beforeGetAuthorizationCounter uint64
	GetAuthorizationMock          mAcmeClientMockGetAuthorization

	funcHTTP01ChallengeResponse          func(token string) (s1 string, err error)
	inspectFuncHTTP01ChallengeResponse   func(token string)
	afterHTTP01ChallengeResponseCounter  uint64
	beforeHTTP01ChallengeResponseCounter uint64
	HTTP01ChallengeResponseMock          mAcmeClientMockHTTP01ChallengeResponse

	funcRevokeAuthorization          func(ctx context.Context, url string) (err error)
	inspectFuncRevokeAuthorization   func(ctx context.Context, url string)
	afterRevokeAuthorizationCounter  uint64
	beforeRevokeAuthorizationCounter uint64
	RevokeAuthorizationMock          mAcmeClientMockRevokeAuthorization

	funcTLSALPN01ChallengeCert          func(token string, domain string, opt ...acme.CertOption) (cert tls.Certificate, err error)
	inspectFuncTLSALPN01ChallengeCert   func(token string, domain string, opt ...acme.CertOption)
	afterTLSALPN01ChallengeCertCounter  uint64
	beforeTLSALPN01ChallengeCertCounter uint64
	TLSALPN01ChallengeCertMock          mAcmeClientMockTLSALPN01ChallengeCert

	funcWaitAuthorization          func(ctx context.Context, url string) (ap1 *acme.Authorization, err error)
	inspectFuncWaitAuthorization   func(ctx context.Context, url string)
	afterWaitAuthorizationCounter  uint64
	beforeWaitAuthorizationCounter uint64
	WaitAuthorizationMock          mAcmeClientMockWaitAuthorization

	funcWaitOrder          func(ctx context.Context, url string) (op1 *acme.Order, err error)
	inspectFuncWaitOrder   func(ctx context.Context, url string)
	afterWaitOrderCounter  uint64
	beforeWaitOrderCounter uint64
	WaitOrderMock          mAcmeClientMockWaitOrder
}

// NewAcmeClientMock returns a mock for AcmeClient
func NewAcmeClientMock(t minimock.Tester) *AcmeClientMock {
	m := &AcmeClientMock{t: t}
	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.AcceptMock = mAcmeClientMockAccept{mock: m}
	m.AcceptMock.callArgs = []*AcmeClientMockAcceptParams{}

	m.AuthorizeOrderMock = mAcmeClientMockAuthorizeOrder{mock: m}
	m.AuthorizeOrderMock.callArgs = []*AcmeClientMockAuthorizeOrderParams{}

	m.CreateOrderCertMock = mAcmeClientMockCreateOrderCert{mock: m}
	m.CreateOrderCertMock.callArgs = []*AcmeClientMockCreateOrderCertParams{}

	m.GetAuthorizationMock = mAcmeClientMockGetAuthorization{mock: m}
	m.GetAuthorizationMock.callArgs = []*AcmeClientMockGetAuthorizationParams{}

	m.HTTP01ChallengeResponseMock = mAcmeClientMockHTTP01ChallengeResponse{mock: m}
	m.HTTP01ChallengeResponseMock.callArgs = []*AcmeClientMockHTTP01ChallengeResponseParams{}

	m.RevokeAuthorizationMock = mAcmeClientMockRevokeAuthorization{mock: m}
	m.RevokeAuthorizationMock.callArgs = []*AcmeClientMockRevokeAuthorizationParams{}

	m.TLSALPN01ChallengeCertMock = mAcmeClientMockTLSALPN01ChallengeCert{mock: m}
	m.TLSALPN01ChallengeCertMock.callArgs = []*AcmeClientMockTLSALPN01ChallengeCertParams{}

	m.WaitAuthorizationMock = mAcmeClientMockWaitAuthorization{mock: m}
	m.WaitAuthorizationMock.callArgs = []*AcmeClientMockWaitAuthorizationParams{}

	m.WaitOrderMock = mAcmeClientMockWaitOrder{mock: m}
	m.WaitOrderMock.callArgs = []*AcmeClientMockWaitOrderParams{}

	return m
}

type mAcmeClientMockAccept struct {
	mock               *AcmeClientMock
	defaultExpectation *AcmeClientMockAcceptExpectation
	expectations       []*AcmeClientMockAcceptExpectation

	callArgs []*AcmeClientMockAcceptParams
	mutex    sync.RWMutex
}

// AcmeClientMockAcceptExpectation specifies expectation struct of the AcmeClient.Accept
type AcmeClientMockAcceptExpectation struct {
	mock    *AcmeClientMock
	params  *AcmeClientMockAcceptParams
	results *AcmeClientMockAcceptResults
	Counter uint64
}

// AcmeClientMockAcceptParams contains parameters of the AcmeClient.Accept
type AcmeClientMockAcceptParams struct {
	ctx  context.Context
	chal *acme.Challenge
}

// AcmeClientMockAcceptResults contains results of the AcmeClient.Accept
type AcmeClientMockAcceptResults struct {
	cp1 *acme.Challenge
	err error
}

// Expect sets up expected params for AcmeClient.Accept
func (mmAccept *mAcmeClientMockAccept) Expect(ctx context.Context, chal *acme.Challenge) *mAcmeClientMockAccept {
	if mmAccept.mock.funcAccept != nil {
		mmAccept.mock.t.Fatalf("AcmeClientMock.Accept mock is already set by Set")
	}

	if mmAccept.defaultExpectation == nil {
		mmAccept.defaultExpectation = &AcmeClientMockAcceptExpectation{}
	}

	mmAccept.defaultExpectation.params = &AcmeClientMockAcceptParams{ctx, chal}
	for _, e := range mmAccept.expectations {
		if minimock.Equal(e.params, mmAccept.defaultExpectation.params) {
			mmAccept.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmAccept.defaultExpectation.params)
		}
	}

	return mmAccept
}

// Inspect accepts an inspector function that has same arguments as the AcmeClient.Accept
func (mmAccept *mAcmeClientMockAccept) Inspect(f func(ctx context.Context, chal *acme.Challenge)) *mAcmeClientMockAccept {
	if mmAccept.mock.inspectFuncAccept != nil {
		mmAccept.mock.t.Fatalf("Inspect function is already set for AcmeClientMock.Accept")
	}

	mmAccept.mock.inspectFuncAccept = f

	return mmAccept
}

// Return sets up results that will be returned by AcmeClient.Accept
func (mmAccept *mAcmeClientMockAccept) Return(cp1 *acme.Challenge, err error) *AcmeClientMock {
	if mmAccept.mock.funcAccept != nil {
		mmAccept.mock.t.Fatalf("AcmeClientMock.Accept mock is already set by Set")
	}

	if mmAccept.defaultExpectation == nil {
		mmAccept.defaultExpectation = &AcmeClientMockAcceptExpectation{mock: mmAccept.mock}
	}
	mmAccept.defaultExpectation.results = &AcmeClientMockAcceptResults{cp1, err}
	return mmAccept.mock
}

//Set uses given function f to mock the AcmeClient.Accept method
func (mmAccept *mAcmeClientMockAccept) Set(f func(ctx context.Context, chal *acme.Challenge) (cp1 *acme.Challenge, err error)) *AcmeClientMock {
	if mmAccept.defaultExpectation != nil {
		mmAccept.mock.t.Fatalf("Default expectation is already set for the AcmeClient.Accept method")
	}

	if len(mmAccept.expectations) > 0 {
		mmAccept.mock.t.Fatalf("Some expectations are already set for the AcmeClient.Accept method")
	}

	mmAccept.mock.funcAccept = f
	return mmAccept.mock
}

// When sets expectation for the AcmeClient.Accept which will trigger the result defined by the following
// Then helper
func (mmAccept *mAcmeClientMockAccept) When(ctx context.Context, chal *acme.Challenge) *AcmeClientMockAcceptExpectation {
	if mmAccept.mock.funcAccept != nil {
		mmAccept.mock.t.Fatalf("AcmeClientMock.Accept mock is already set by Set")
	}

	expectation := &AcmeClientMockAcceptExpectation{
		mock:   mmAccept.mock,
		params: &AcmeClientMockAcceptParams{ctx, chal},
	}
	mmAccept.expectations = append(mmAccept.expectations, expectation)
	return expectation
}

// Then sets up AcmeClient.Accept return parameters for the expectation previously defined by the When method
func (e *AcmeClientMockAcceptExpectation) Then(cp1 *acme.Challenge, err error) *AcmeClientMock {
	e.results = &AcmeClientMockAcceptResults{cp1, err}
	return e.mock
}

// Accept implements AcmeClient
func (mmAccept *AcmeClientMock) Accept(ctx context.Context, chal *acme.Challenge) (cp1 *acme.Challenge, err error) {
	mm_atomic.AddUint64(&mmAccept.beforeAcceptCounter, 1)
	defer mm_atomic.AddUint64(&mmAccept.afterAcceptCounter, 1)

	if mmAccept.inspectFuncAccept != nil {
		mmAccept.inspectFuncAccept(ctx, chal)
	}

	mm_params := &AcmeClientMockAcceptParams{ctx, chal}

	// Record call args
	mmAccept.AcceptMock.mutex.Lock()
	mmAccept.AcceptMock.callArgs = append(mmAccept.AcceptMock.callArgs, mm_params)
	mmAccept.AcceptMock.mutex.Unlock()

	for _, e := range mmAccept.AcceptMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.cp1, e.results.err
		}
	}

	if mmAccept.AcceptMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmAccept.AcceptMock.defaultExpectation.Counter, 1)
		mm_want := mmAccept.AcceptMock.defaultExpectation.params
		mm_got := AcmeClientMockAcceptParams{ctx, chal}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmAccept.t.Errorf("AcmeClientMock.Accept got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmAccept.AcceptMock.defaultExpectation.results
		if mm_results == nil {
			mmAccept.t.Fatal("No results are set for the AcmeClientMock.Accept")
		}
		return (*mm_results).cp1, (*mm_results).err
	}
	if mmAccept.funcAccept != nil {
		return mmAccept.funcAccept(ctx, chal)
	}
	mmAccept.t.Fatalf("Unexpected call to AcmeClientMock.Accept. %v %v", ctx, chal)
	return
}

// AcceptAfterCounter returns a count of finished AcmeClientMock.Accept invocations
func (mmAccept *AcmeClientMock) AcceptAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmAccept.afterAcceptCounter)
}

// AcceptBeforeCounter returns a count of AcmeClientMock.Accept invocations
func (mmAccept *AcmeClientMock) AcceptBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmAccept.beforeAcceptCounter)
}

// Calls returns a list of arguments used in each call to AcmeClientMock.Accept.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmAccept *mAcmeClientMockAccept) Calls() []*AcmeClientMockAcceptParams {
	mmAccept.mutex.RLock()

	argCopy := make([]*AcmeClientMockAcceptParams, len(mmAccept.callArgs))
	copy(argCopy, mmAccept.callArgs)

	mmAccept.mutex.RUnlock()

	return argCopy
}

// MinimockAcceptDone returns true if the count of the Accept invocations corresponds
// the number of defined expectations
func (m *AcmeClientMock) MinimockAcceptDone() bool {
	for _, e := range m.AcceptMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.AcceptMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterAcceptCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcAccept != nil && mm_atomic.LoadUint64(&m.afterAcceptCounter) < 1 {
		return false
	}
	return true
}

// MinimockAcceptInspect logs each unmet expectation
func (m *AcmeClientMock) MinimockAcceptInspect() {
	for _, e := range m.AcceptMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to AcmeClientMock.Accept with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.AcceptMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterAcceptCounter) < 1 {
		if m.AcceptMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to AcmeClientMock.Accept")
		} else {
			m.t.Errorf("Expected call to AcmeClientMock.Accept with params: %#v", *m.AcceptMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcAccept != nil && mm_atomic.LoadUint64(&m.afterAcceptCounter) < 1 {
		m.t.Error("Expected call to AcmeClientMock.Accept")
	}
}

type mAcmeClientMockAuthorizeOrder struct {
	mock               *AcmeClientMock
	defaultExpectation *AcmeClientMockAuthorizeOrderExpectation
	expectations       []*AcmeClientMockAuthorizeOrderExpectation

	callArgs []*AcmeClientMockAuthorizeOrderParams
	mutex    sync.RWMutex
}

// AcmeClientMockAuthorizeOrderExpectation specifies expectation struct of the AcmeClient.AuthorizeOrder
type AcmeClientMockAuthorizeOrderExpectation struct {
	mock    *AcmeClientMock
	params  *AcmeClientMockAuthorizeOrderParams
	results *AcmeClientMockAuthorizeOrderResults
	Counter uint64
}

// AcmeClientMockAuthorizeOrderParams contains parameters of the AcmeClient.AuthorizeOrder
type AcmeClientMockAuthorizeOrderParams struct {
	ctx context.Context
	id  []acme.AuthzID
	opt []acme.OrderOption
}

// AcmeClientMockAuthorizeOrderResults contains results of the AcmeClient.AuthorizeOrder
type AcmeClientMockAuthorizeOrderResults struct {
	op1 *acme.Order
	err error
}

// Expect sets up expected params for AcmeClient.AuthorizeOrder
func (mmAuthorizeOrder *mAcmeClientMockAuthorizeOrder) Expect(ctx context.Context, id []acme.AuthzID, opt ...acme.OrderOption) *mAcmeClientMockAuthorizeOrder {
	if mmAuthorizeOrder.mock.funcAuthorizeOrder != nil {
		mmAuthorizeOrder.mock.t.Fatalf("AcmeClientMock.AuthorizeOrder mock is already set by Set")
	}

	if mmAuthorizeOrder.defaultExpectation == nil {
		mmAuthorizeOrder.defaultExpectation = &AcmeClientMockAuthorizeOrderExpectation{}
	}

	mmAuthorizeOrder.defaultExpectation.params = &AcmeClientMockAuthorizeOrderParams{ctx, id, opt}
	for _, e := range mmAuthorizeOrder.expectations {
		if minimock.Equal(e.params, mmAuthorizeOrder.defaultExpectation.params) {
			mmAuthorizeOrder.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmAuthorizeOrder.defaultExpectation.params)
		}
	}

	return mmAuthorizeOrder
}

// Inspect accepts an inspector function that has same arguments as the AcmeClient.AuthorizeOrder
func (mmAuthorizeOrder *mAcmeClientMockAuthorizeOrder) Inspect(f func(ctx context.Context, id []acme.AuthzID, opt ...acme.OrderOption)) *mAcmeClientMockAuthorizeOrder {
	if mmAuthorizeOrder.mock.inspectFuncAuthorizeOrder != nil {
		mmAuthorizeOrder.mock.t.Fatalf("Inspect function is already set for AcmeClientMock.AuthorizeOrder")
	}

	mmAuthorizeOrder.mock.inspectFuncAuthorizeOrder = f

	return mmAuthorizeOrder
}

// Return sets up results that will be returned by AcmeClient.AuthorizeOrder
func (mmAuthorizeOrder *mAcmeClientMockAuthorizeOrder) Return(op1 *acme.Order, err error) *AcmeClientMock {
	if mmAuthorizeOrder.mock.funcAuthorizeOrder != nil {
		mmAuthorizeOrder.mock.t.Fatalf("AcmeClientMock.AuthorizeOrder mock is already set by Set")
	}

	if mmAuthorizeOrder.defaultExpectation == nil {
		mmAuthorizeOrder.defaultExpectation = &AcmeClientMockAuthorizeOrderExpectation{mock: mmAuthorizeOrder.mock}
	}
	mmAuthorizeOrder.defaultExpectation.results = &AcmeClientMockAuthorizeOrderResults{op1, err}
	return mmAuthorizeOrder.mock
}

//Set uses given function f to mock the AcmeClient.AuthorizeOrder method
func (mmAuthorizeOrder *mAcmeClientMockAuthorizeOrder) Set(f func(ctx context.Context, id []acme.AuthzID, opt ...acme.OrderOption) (op1 *acme.Order, err error)) *AcmeClientMock {
	if mmAuthorizeOrder.defaultExpectation != nil {
		mmAuthorizeOrder.mock.t.Fatalf("Default expectation is already set for the AcmeClient.AuthorizeOrder method")
	}

	if len(mmAuthorizeOrder.expectations) > 0 {
		mmAuthorizeOrder.mock.t.Fatalf("Some expectations are already set for the AcmeClient.AuthorizeOrder method")
	}

	mmAuthorizeOrder.mock.funcAuthorizeOrder = f
	return mmAuthorizeOrder.mock
}

// When sets expectation for the AcmeClient.AuthorizeOrder which will trigger the result defined by the following
// Then helper
func (mmAuthorizeOrder *mAcmeClientMockAuthorizeOrder) When(ctx context.Context, id []acme.AuthzID, opt ...acme.OrderOption) *AcmeClientMockAuthorizeOrderExpectation {
	if mmAuthorizeOrder.mock.funcAuthorizeOrder != nil {
		mmAuthorizeOrder.mock.t.Fatalf("AcmeClientMock.AuthorizeOrder mock is already set by Set")
	}

	expectation := &AcmeClientMockAuthorizeOrderExpectation{
		mock:   mmAuthorizeOrder.mock,
		params: &AcmeClientMockAuthorizeOrderParams{ctx, id, opt},
	}
	mmAuthorizeOrder.expectations = append(mmAuthorizeOrder.expectations, expectation)
	return expectation
}

// Then sets up AcmeClient.AuthorizeOrder return parameters for the expectation previously defined by the When method
func (e *AcmeClientMockAuthorizeOrderExpectation) Then(op1 *acme.Order, err error) *AcmeClientMock {
	e.results = &AcmeClientMockAuthorizeOrderResults{op1, err}
	return e.mock
}

// AuthorizeOrder implements AcmeClient
func (mmAuthorizeOrder *AcmeClientMock) AuthorizeOrder(ctx context.Context, id []acme.AuthzID, opt ...acme.OrderOption) (op1 *acme.Order, err error) {
	mm_atomic.AddUint64(&mmAuthorizeOrder.beforeAuthorizeOrderCounter, 1)
	defer mm_atomic.AddUint64(&mmAuthorizeOrder.afterAuthorizeOrderCounter, 1)

	if mmAuthorizeOrder.inspectFuncAuthorizeOrder != nil {
		mmAuthorizeOrder.inspectFuncAuthorizeOrder(ctx, id, opt...)
	}

	mm_params := &AcmeClientMockAuthorizeOrderParams{ctx, id, opt}

	// Record call args
	mmAuthorizeOrder.AuthorizeOrderMock.mutex.Lock()
	mmAuthorizeOrder.AuthorizeOrderMock.callArgs = append(mmAuthorizeOrder.AuthorizeOrderMock.callArgs, mm_params)
	mmAuthorizeOrder.AuthorizeOrderMock.mutex.Unlock()

	for _, e := range mmAuthorizeOrder.AuthorizeOrderMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.op1, e.results.err
		}
	}

	if mmAuthorizeOrder.AuthorizeOrderMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmAuthorizeOrder.AuthorizeOrderMock.defaultExpectation.Counter, 1)
		mm_want := mmAuthorizeOrder.AuthorizeOrderMock.defaultExpectation.params
		mm_got := AcmeClientMockAuthorizeOrderParams{ctx, id, opt}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmAuthorizeOrder.t.Errorf("AcmeClientMock.AuthorizeOrder got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmAuthorizeOrder.AuthorizeOrderMock.defaultExpectation.results
		if mm_results == nil {
			mmAuthorizeOrder.t.Fatal("No results are set for the AcmeClientMock.AuthorizeOrder")
		}
		return (*mm_results).op1, (*mm_results).err
	}
	if mmAuthorizeOrder.funcAuthorizeOrder != nil {
		return mmAuthorizeOrder.funcAuthorizeOrder(ctx, id, opt...)
	}
	mmAuthorizeOrder.t.Fatalf("Unexpected call to AcmeClientMock.AuthorizeOrder. %v %v %v", ctx, id, opt)
	return
}

// AuthorizeOrderAfterCounter returns a count of finished AcmeClientMock.AuthorizeOrder invocations
func (mmAuthorizeOrder *AcmeClientMock) AuthorizeOrderAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmAuthorizeOrder.afterAuthorizeOrderCounter)
}

// AuthorizeOrderBeforeCounter returns a count of AcmeClientMock.AuthorizeOrder invocations
func (mmAuthorizeOrder *AcmeClientMock) AuthorizeOrderBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmAuthorizeOrder.beforeAuthorizeOrderCounter)
}

// Calls returns a list of arguments used in each call to AcmeClientMock.AuthorizeOrder.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmAuthorizeOrder *mAcmeClientMockAuthorizeOrder) Calls() []*AcmeClientMockAuthorizeOrderParams {
	mmAuthorizeOrder.mutex.RLock()

	argCopy := make([]*AcmeClientMockAuthorizeOrderParams, len(mmAuthorizeOrder.callArgs))
	copy(argCopy, mmAuthorizeOrder.callArgs)

	mmAuthorizeOrder.mutex.RUnlock()

	return argCopy
}

// MinimockAuthorizeOrderDone returns true if the count of the AuthorizeOrder invocations corresponds
// the number of defined expectations
func (m *AcmeClientMock) MinimockAuthorizeOrderDone() bool {
	for _, e := range m.AuthorizeOrderMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.AuthorizeOrderMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterAuthorizeOrderCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcAuthorizeOrder != nil && mm_atomic.LoadUint64(&m.afterAuthorizeOrderCounter) < 1 {
		return false
	}
	return true
}

// MinimockAuthorizeOrderInspect logs each unmet expectation
func (m *AcmeClientMock) MinimockAuthorizeOrderInspect() {
	for _, e := range m.AuthorizeOrderMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to AcmeClientMock.AuthorizeOrder with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.AuthorizeOrderMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterAuthorizeOrderCounter) < 1 {
		if m.AuthorizeOrderMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to AcmeClientMock.AuthorizeOrder")
		} else {
			m.t.Errorf("Expected call to AcmeClientMock.AuthorizeOrder with params: %#v", *m.AuthorizeOrderMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcAuthorizeOrder != nil && mm_atomic.LoadUint64(&m.afterAuthorizeOrderCounter) < 1 {
		m.t.Error("Expected call to AcmeClientMock.AuthorizeOrder")
	}
}

type mAcmeClientMockCreateOrderCert struct {
	mock               *AcmeClientMock
	defaultExpectation *AcmeClientMockCreateOrderCertExpectation
	expectations       []*AcmeClientMockCreateOrderCertExpectation

	callArgs []*AcmeClientMockCreateOrderCertParams
	mutex    sync.RWMutex
}

// AcmeClientMockCreateOrderCertExpectation specifies expectation struct of the AcmeClient.CreateOrderCert
type AcmeClientMockCreateOrderCertExpectation struct {
	mock    *AcmeClientMock
	params  *AcmeClientMockCreateOrderCertParams
	results *AcmeClientMockCreateOrderCertResults
	Counter uint64
}

// AcmeClientMockCreateOrderCertParams contains parameters of the AcmeClient.CreateOrderCert
type AcmeClientMockCreateOrderCertParams struct {
	ctx    context.Context
	url    string
	csr    []byte
	bundle bool
}

// AcmeClientMockCreateOrderCertResults contains results of the AcmeClient.CreateOrderCert
type AcmeClientMockCreateOrderCertResults struct {
	der     [][]byte
	certURL string
	err     error
}

// Expect sets up expected params for AcmeClient.CreateOrderCert
func (mmCreateOrderCert *mAcmeClientMockCreateOrderCert) Expect(ctx context.Context, url string, csr []byte, bundle bool) *mAcmeClientMockCreateOrderCert {
	if mmCreateOrderCert.mock.funcCreateOrderCert != nil {
		mmCreateOrderCert.mock.t.Fatalf("AcmeClientMock.CreateOrderCert mock is already set by Set")
	}

	if mmCreateOrderCert.defaultExpectation == nil {
		mmCreateOrderCert.defaultExpectation = &AcmeClientMockCreateOrderCertExpectation{}
	}

	mmCreateOrderCert.defaultExpectation.params = &AcmeClientMockCreateOrderCertParams{ctx, url, csr, bundle}
	for _, e := range mmCreateOrderCert.expectations {
		if minimock.Equal(e.params, mmCreateOrderCert.defaultExpectation.params) {
			mmCreateOrderCert.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmCreateOrderCert.defaultExpectation.params)
		}
	}

	return mmCreateOrderCert
}

// Inspect accepts an inspector function that has same arguments as the AcmeClient.CreateOrderCert
func (mmCreateOrderCert *mAcmeClientMockCreateOrderCert) Inspect(f func(ctx context.Context, url string, csr []byte, bundle bool)) *mAcmeClientMockCreateOrderCert {
	if mmCreateOrderCert.mock.inspectFuncCreateOrderCert != nil {
		mmCreateOrderCert.mock.t.Fatalf("Inspect function is already set for AcmeClientMock.CreateOrderCert")
	}

	mmCreateOrderCert.mock.inspectFuncCreateOrderCert = f

	return mmCreateOrderCert
}

// Return sets up results that will be returned by AcmeClient.CreateOrderCert
func (mmCreateOrderCert *mAcmeClientMockCreateOrderCert) Return(der [][]byte, certURL string, err error) *AcmeClientMock {
	if mmCreateOrderCert.mock.funcCreateOrderCert != nil {
		mmCreateOrderCert.mock.t.Fatalf("AcmeClientMock.CreateOrderCert mock is already set by Set")
	}

	if mmCreateOrderCert.defaultExpectation == nil {
		mmCreateOrderCert.defaultExpectation = &AcmeClientMockCreateOrderCertExpectation{mock: mmCreateOrderCert.mock}
	}
	mmCreateOrderCert.defaultExpectation.results = &AcmeClientMockCreateOrderCertResults{der, certURL, err}
	return mmCreateOrderCert.mock
}

//Set uses given function f to mock the AcmeClient.CreateOrderCert method
func (mmCreateOrderCert *mAcmeClientMockCreateOrderCert) Set(f func(ctx context.Context, url string, csr []byte, bundle bool) (der [][]byte, certURL string, err error)) *AcmeClientMock {
	if mmCreateOrderCert.defaultExpectation != nil {
		mmCreateOrderCert.mock.t.Fatalf("Default expectation is already set for the AcmeClient.CreateOrderCert method")
	}

	if len(mmCreateOrderCert.expectations) > 0 {
		mmCreateOrderCert.mock.t.Fatalf("Some expectations are already set for the AcmeClient.CreateOrderCert method")
	}

	mmCreateOrderCert.mock.funcCreateOrderCert = f
	return mmCreateOrderCert.mock
}

// When sets expectation for the AcmeClient.CreateOrderCert which will trigger the result defined by the following
// Then helper
func (mmCreateOrderCert *mAcmeClientMockCreateOrderCert) When(ctx context.Context, url string, csr []byte, bundle bool) *AcmeClientMockCreateOrderCertExpectation {
	if mmCreateOrderCert.mock.funcCreateOrderCert != nil {
		mmCreateOrderCert.mock.t.Fatalf("AcmeClientMock.CreateOrderCert mock is already set by Set")
	}

	expectation := &AcmeClientMockCreateOrderCertExpectation{
		mock:   mmCreateOrderCert.mock,
		params: &AcmeClientMockCreateOrderCertParams{ctx, url, csr, bundle},
	}
	mmCreateOrderCert.expectations = append(mmCreateOrderCert.expectations, expectation)
	return expectation
}

// Then sets up AcmeClient.CreateOrderCert return parameters for the expectation previously defined by the When method
func (e *AcmeClientMockCreateOrderCertExpectation) Then(der [][]byte, certURL string, err error) *AcmeClientMock {
	e.results = &AcmeClientMockCreateOrderCertResults{der, certURL, err}
	return e.mock
}

// CreateOrderCert implements AcmeClient
func (mmCreateOrderCert *AcmeClientMock) CreateOrderCert(ctx context.Context, url string, csr []byte, bundle bool) (der [][]byte, certURL string, err error) {
	mm_atomic.AddUint64(&mmCreateOrderCert.beforeCreateOrderCertCounter, 1)
	defer mm_atomic.AddUint64(&mmCreateOrderCert.afterCreateOrderCertCounter, 1)

	if mmCreateOrderCert.inspectFuncCreateOrderCert != nil {
		mmCreateOrderCert.inspectFuncCreateOrderCert(ctx, url, csr, bundle)
	}

	mm_params := &AcmeClientMockCreateOrderCertParams{ctx, url, csr, bundle}

	// Record call args
	mmCreateOrderCert.CreateOrderCertMock.mutex.Lock()
	mmCreateOrderCert.CreateOrderCertMock.callArgs = append(mmCreateOrderCert.CreateOrderCertMock.callArgs, mm_params)
	mmCreateOrderCert.CreateOrderCertMock.mutex.Unlock()

	for _, e := range mmCreateOrderCert.CreateOrderCertMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.der, e.results.certURL, e.results.err
		}
	}

	if mmCreateOrderCert.CreateOrderCertMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmCreateOrderCert.CreateOrderCertMock.defaultExpectation.Counter, 1)
		mm_want := mmCreateOrderCert.CreateOrderCertMock.defaultExpectation.params
		mm_got := AcmeClientMockCreateOrderCertParams{ctx, url, csr, bundle}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmCreateOrderCert.t.Errorf("AcmeClientMock.CreateOrderCert got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmCreateOrderCert.CreateOrderCertMock.defaultExpectation.results
		if mm_results == nil {
			mmCreateOrderCert.t.Fatal("No results are set for the AcmeClientMock.CreateOrderCert")
		}
		return (*mm_results).der, (*mm_results).certURL, (*mm_results).err
	}
	if mmCreateOrderCert.funcCreateOrderCert != nil {
		return mmCreateOrderCert.funcCreateOrderCert(ctx, url, csr, bundle)
	}
	mmCreateOrderCert.t.Fatalf("Unexpected call to AcmeClientMock.CreateOrderCert. %v %v %v %v", ctx, url, csr, bundle)
	return
}

// CreateOrderCertAfterCounter returns a count of finished AcmeClientMock.CreateOrderCert invocations
func (mmCreateOrderCert *AcmeClientMock) CreateOrderCertAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreateOrderCert.afterCreateOrderCertCounter)
}

// CreateOrderCertBeforeCounter returns a count of AcmeClientMock.CreateOrderCert invocations
func (mmCreateOrderCert *AcmeClientMock) CreateOrderCertBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreateOrderCert.beforeCreateOrderCertCounter)
}

// Calls returns a list of arguments used in each call to AcmeClientMock.CreateOrderCert.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmCreateOrderCert *mAcmeClientMockCreateOrderCert) Calls() []*AcmeClientMockCreateOrderCertParams {
	mmCreateOrderCert.mutex.RLock()

	argCopy := make([]*AcmeClientMockCreateOrderCertParams, len(mmCreateOrderCert.callArgs))
	copy(argCopy, mmCreateOrderCert.callArgs)

	mmCreateOrderCert.mutex.RUnlock()

	return argCopy
}

// MinimockCreateOrderCertDone returns true if the count of the CreateOrderCert invocations corresponds
// the number of defined expectations
func (m *AcmeClientMock) MinimockCreateOrderCertDone() bool {
	for _, e := range m.CreateOrderCertMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.CreateOrderCertMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterCreateOrderCertCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCreateOrderCert != nil && mm_atomic.LoadUint64(&m.afterCreateOrderCertCounter) < 1 {
		return false
	}
	return true
}

// MinimockCreateOrderCertInspect logs each unmet expectation
func (m *AcmeClientMock) MinimockCreateOrderCertInspect() {
	for _, e := range m.CreateOrderCertMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to AcmeClientMock.CreateOrderCert with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.CreateOrderCertMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterCreateOrderCertCounter) < 1 {
		if m.CreateOrderCertMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to AcmeClientMock.CreateOrderCert")
		} else {
			m.t.Errorf("Expected call to AcmeClientMock.CreateOrderCert with params: %#v", *m.CreateOrderCertMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCreateOrderCert != nil && mm_atomic.LoadUint64(&m.afterCreateOrderCertCounter) < 1 {
		m.t.Error("Expected call to AcmeClientMock.CreateOrderCert")
	}
}

type mAcmeClientMockGetAuthorization struct {
	mock               *AcmeClientMock
	defaultExpectation *AcmeClientMockGetAuthorizationExpectation
	expectations       []*AcmeClientMockGetAuthorizationExpectation

	callArgs []*AcmeClientMockGetAuthorizationParams
	mutex    sync.RWMutex
}

// AcmeClientMockGetAuthorizationExpectation specifies expectation struct of the AcmeClient.GetAuthorization
type AcmeClientMockGetAuthorizationExpectation struct {
	mock    *AcmeClientMock
	params  *AcmeClientMockGetAuthorizationParams
	results *AcmeClientMockGetAuthorizationResults
	Counter uint64
}

// AcmeClientMockGetAuthorizationParams contains parameters of the AcmeClient.GetAuthorization
type AcmeClientMockGetAuthorizationParams struct {
	ctx context.Context
	url string
}

// AcmeClientMockGetAuthorizationResults contains results of the AcmeClient.GetAuthorization
type AcmeClientMockGetAuthorizationResults struct {
	ap1 *acme.Authorization
	err error
}

// Expect sets up expected params for AcmeClient.GetAuthorization
func (mmGetAuthorization *mAcmeClientMockGetAuthorization) Expect(ctx context.Context, url string) *mAcmeClientMockGetAuthorization {
	if mmGetAuthorization.mock.funcGetAuthorization != nil {
		mmGetAuthorization.mock.t.Fatalf("AcmeClientMock.GetAuthorization mock is already set by Set")
	}

	if mmGetAuthorization.defaultExpectation == nil {
		mmGetAuthorization.defaultExpectation = &AcmeClientMockGetAuthorizationExpectation{}
	}

	mmGetAuthorization.defaultExpectation.params = &AcmeClientMockGetAuthorizationParams{ctx, url}
	for _, e := range mmGetAuthorization.expectations {
		if minimock.Equal(e.params, mmGetAuthorization.defaultExpectation.params) {
			mmGetAuthorization.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetAuthorization.defaultExpectation.params)
		}
	}

	return mmGetAuthorization
}

// Inspect accepts an inspector function that has same arguments as the AcmeClient.GetAuthorization
func (mmGetAuthorization *mAcmeClientMockGetAuthorization) Inspect(f func(ctx context.Context, url string)) *mAcmeClientMockGetAuthorization {
	if mmGetAuthorization.mock.inspectFuncGetAuthorization != nil {
		mmGetAuthorization.mock.t.Fatalf("Inspect function is already set for AcmeClientMock.GetAuthorization")
	}

	mmGetAuthorization.mock.inspectFuncGetAuthorization = f

	return mmGetAuthorization
}

// Return sets up results that will be returned by AcmeClient.GetAuthorization
func (mmGetAuthorization *mAcmeClientMockGetAuthorization) Return(ap1 *acme.Authorization, err error) *AcmeClientMock {
	if mmGetAuthorization.mock.funcGetAuthorization != nil {
		mmGetAuthorization.mock.t.Fatalf("AcmeClientMock.GetAuthorization mock is already set by Set")
	}

	if mmGetAuthorization.defaultExpectation == nil {
		mmGetAuthorization.defaultExpectation = &AcmeClientMockGetAuthorizationExpectation{mock: mmGetAuthorization.mock}
	}
	mmGetAuthorization.defaultExpectation.results = &AcmeClientMockGetAuthorizationResults{ap1, err}
	return mmGetAuthorization.mock
}

//Set uses given function f to mock the AcmeClient.GetAuthorization method
func (mmGetAuthorization *mAcmeClientMockGetAuthorization) Set(f func(ctx context.Context, url string) (ap1 *acme.Authorization, err error)) *AcmeClientMock {
	if mmGetAuthorization.defaultExpectation != nil {
		mmGetAuthorization.mock.t.Fatalf("Default expectation is already set for the AcmeClient.GetAuthorization method")
	}

	if len(mmGetAuthorization.expectations) > 0 {
		mmGetAuthorization.mock.t.Fatalf("Some expectations are already set for the AcmeClient.GetAuthorization method")
	}

	mmGetAuthorization.mock.funcGetAuthorization = f
	return mmGetAuthorization.mock
}

// When sets expectation for the AcmeClient.GetAuthorization which will trigger the result defined by the following
// Then helper
func (mmGetAuthorization *mAcmeClientMockGetAuthorization) When(ctx context.Context, url string) *AcmeClientMockGetAuthorizationExpectation {
	if mmGetAuthorization.mock.funcGetAuthorization != nil {
		mmGetAuthorization.mock.t.Fatalf("AcmeClientMock.GetAuthorization mock is already set by Set")
	}

	expectation := &AcmeClientMockGetAuthorizationExpectation{
		mock:   mmGetAuthorization.mock,
		params: &AcmeClientMockGetAuthorizationParams{ctx, url},
	}
	mmGetAuthorization.expectations = append(mmGetAuthorization.expectations, expectation)
	return expectation
}

// Then sets up AcmeClient.GetAuthorization return parameters for the expectation previously defined by the When method
func (e *AcmeClientMockGetAuthorizationExpectation) Then(ap1 *acme.Authorization, err error) *AcmeClientMock {
	e.results = &AcmeClientMockGetAuthorizationResults{ap1, err}
	return e.mock
}

// GetAuthorization implements AcmeClient
func (mmGetAuthorization *AcmeClientMock) GetAuthorization(ctx context.Context, url string) (ap1 *acme.Authorization, err error) {
	mm_atomic.AddUint64(&mmGetAuthorization.beforeGetAuthorizationCounter, 1)
	defer mm_atomic.AddUint64(&mmGetAuthorization.afterGetAuthorizationCounter, 1)

	if mmGetAuthorization.inspectFuncGetAuthorization != nil {
		mmGetAuthorization.inspectFuncGetAuthorization(ctx, url)
	}

	mm_params := &AcmeClientMockGetAuthorizationParams{ctx, url}

	// Record call args
	mmGetAuthorization.GetAuthorizationMock.mutex.Lock()
	mmGetAuthorization.GetAuthorizationMock.callArgs = append(mmGetAuthorization.GetAuthorizationMock.callArgs, mm_params)
	mmGetAuthorization.GetAuthorizationMock.mutex.Unlock()

	for _, e := range mmGetAuthorization.GetAuthorizationMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.ap1, e.results.err
		}
	}

	if mmGetAuthorization.GetAuthorizationMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetAuthorization.GetAuthorizationMock.defaultExpectation.Counter, 1)
		mm_want := mmGetAuthorization.GetAuthorizationMock.defaultExpectation.params
		mm_got := AcmeClientMockGetAuthorizationParams{ctx, url}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetAuthorization.t.Errorf("AcmeClientMock.GetAuthorization got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetAuthorization.GetAuthorizationMock.defaultExpectation.results
		if mm_results == nil {
			mmGetAuthorization.t.Fatal("No results are set for the AcmeClientMock.GetAuthorization")
		}
		return (*mm_results).ap1, (*mm_results).err
	}
	if mmGetAuthorization.funcGetAuthorization != nil {
		return mmGetAuthorization.funcGetAuthorization(ctx, url)
	}
	mmGetAuthorization.t.Fatalf("Unexpected call to AcmeClientMock.GetAuthorization. %v %v", ctx, url)
	return
}

// GetAuthorizationAfterCounter returns a count of finished AcmeClientMock.GetAuthorization invocations
func (mmGetAuthorization *AcmeClientMock) GetAuthorizationAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetAuthorization.afterGetAuthorizationCounter)
}

// GetAuthorizationBeforeCounter returns a count of AcmeClientMock.GetAuthorization invocations
func (mmGetAuthorization *AcmeClientMock) GetAuthorizationBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetAuthorization.beforeGetAuthorizationCounter)
}

// Calls returns a list of arguments used in each call to AcmeClientMock.GetAuthorization.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetAuthorization *mAcmeClientMockGetAuthorization) Calls() []*AcmeClientMockGetAuthorizationParams {
	mmGetAuthorization.mutex.RLock()

	argCopy := make([]*AcmeClientMockGetAuthorizationParams, len(mmGetAuthorization.callArgs))
	copy(argCopy, mmGetAuthorization.callArgs)

	mmGetAuthorization.mutex.RUnlock()

	return argCopy
}

// MinimockGetAuthorizationDone returns true if the count of the GetAuthorization invocations corresponds
// the number of defined expectations
func (m *AcmeClientMock) MinimockGetAuthorizationDone() bool {
	for _, e := range m.GetAuthorizationMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetAuthorizationMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetAuthorizationCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetAuthorization != nil && mm_atomic.LoadUint64(&m.afterGetAuthorizationCounter) < 1 {
		return false
	}
	return true
}

// MinimockGetAuthorizationInspect logs each unmet expectation
func (m *AcmeClientMock) MinimockGetAuthorizationInspect() {
	for _, e := range m.GetAuthorizationMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to AcmeClientMock.GetAuthorization with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetAuthorizationMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetAuthorizationCounter) < 1 {
		if m.GetAuthorizationMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to AcmeClientMock.GetAuthorization")
		} else {
			m.t.Errorf("Expected call to AcmeClientMock.GetAuthorization with params: %#v", *m.GetAuthorizationMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetAuthorization != nil && mm_atomic.LoadUint64(&m.afterGetAuthorizationCounter) < 1 {
		m.t.Error("Expected call to AcmeClientMock.GetAuthorization")
	}
}

type mAcmeClientMockHTTP01ChallengeResponse struct {
	mock               *AcmeClientMock
	defaultExpectation *AcmeClientMockHTTP01ChallengeResponseExpectation
	expectations       []*AcmeClientMockHTTP01ChallengeResponseExpectation

	callArgs []*AcmeClientMockHTTP01ChallengeResponseParams
	mutex    sync.RWMutex
}

// AcmeClientMockHTTP01ChallengeResponseExpectation specifies expectation struct of the AcmeClient.HTTP01ChallengeResponse
type AcmeClientMockHTTP01ChallengeResponseExpectation struct {
	mock    *AcmeClientMock
	params  *AcmeClientMockHTTP01ChallengeResponseParams
	results *AcmeClientMockHTTP01ChallengeResponseResults
	Counter uint64
}

// AcmeClientMockHTTP01ChallengeResponseParams contains parameters of the AcmeClient.HTTP01ChallengeResponse
type AcmeClientMockHTTP01ChallengeResponseParams struct {
	token string
}

// AcmeClientMockHTTP01ChallengeResponseResults contains results of the AcmeClient.HTTP01ChallengeResponse
type AcmeClientMockHTTP01ChallengeResponseResults struct {
	s1  string
	err error
}

// Expect sets up expected params for AcmeClient.HTTP01ChallengeResponse
func (mmHTTP01ChallengeResponse *mAcmeClientMockHTTP01ChallengeResponse) Expect(token string) *mAcmeClientMockHTTP01ChallengeResponse {
	if mmHTTP01ChallengeResponse.mock.funcHTTP01ChallengeResponse != nil {
		mmHTTP01ChallengeResponse.mock.t.Fatalf("AcmeClientMock.HTTP01ChallengeResponse mock is already set by Set")
	}

	if mmHTTP01ChallengeResponse.defaultExpectation == nil {
		mmHTTP01ChallengeResponse.defaultExpectation = &AcmeClientMockHTTP01ChallengeResponseExpectation{}
	}

	mmHTTP01ChallengeResponse.defaultExpectation.params = &AcmeClientMockHTTP01ChallengeResponseParams{token}
	for _, e := range mmHTTP01ChallengeResponse.expectations {
		if minimock.Equal(e.params, mmHTTP01ChallengeResponse.defaultExpectation.params) {
			mmHTTP01ChallengeResponse.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmHTTP01ChallengeResponse.defaultExpectation.params)
		}
	}

	return mmHTTP01ChallengeResponse
}

// Inspect accepts an inspector function that has same arguments as the AcmeClient.HTTP01ChallengeResponse
func (mmHTTP01ChallengeResponse *mAcmeClientMockHTTP01ChallengeResponse) Inspect(f func(token string)) *mAcmeClientMockHTTP01ChallengeResponse {
	if mmHTTP01ChallengeResponse.mock.inspectFuncHTTP01ChallengeResponse != nil {
		mmHTTP01ChallengeResponse.mock.t.Fatalf("Inspect function is already set for AcmeClientMock.HTTP01ChallengeResponse")
	}

	mmHTTP01ChallengeResponse.mock.inspectFuncHTTP01ChallengeResponse = f

	return mmHTTP01ChallengeResponse
}

// Return sets up results that will be returned by AcmeClient.HTTP01ChallengeResponse
func (mmHTTP01ChallengeResponse *mAcmeClientMockHTTP01ChallengeResponse) Return(s1 string, err error) *AcmeClientMock {
	if mmHTTP01ChallengeResponse.mock.funcHTTP01ChallengeResponse != nil {
		mmHTTP01ChallengeResponse.mock.t.Fatalf("AcmeClientMock.HTTP01ChallengeResponse mock is already set by Set")
	}

	if mmHTTP01ChallengeResponse.defaultExpectation == nil {
		mmHTTP01ChallengeResponse.defaultExpectation = &AcmeClientMockHTTP01ChallengeResponseExpectation{mock: mmHTTP01ChallengeResponse.mock}
	}
	mmHTTP01ChallengeResponse.defaultExpectation.results = &AcmeClientMockHTTP01ChallengeResponseResults{s1, err}
	return mmHTTP01ChallengeResponse.mock
}

//Set uses given function f to mock the AcmeClient.HTTP01ChallengeResponse method
func (mmHTTP01ChallengeResponse *mAcmeClientMockHTTP01ChallengeResponse) Set(f func(token string) (s1 string, err error)) *AcmeClientMock {
	if mmHTTP01ChallengeResponse.defaultExpectation != nil {
		mmHTTP01ChallengeResponse.mock.t.Fatalf("Default expectation is already set for the AcmeClient.HTTP01ChallengeResponse method")
	}

	if len(mmHTTP01ChallengeResponse.expectations) > 0 {
		mmHTTP01ChallengeResponse.mock.t.Fatalf("Some expectations are already set for the AcmeClient.HTTP01ChallengeResponse method")
	}

	mmHTTP01ChallengeResponse.mock.funcHTTP01ChallengeResponse = f
	return mmHTTP01ChallengeResponse.mock
}

// When sets expectation for the AcmeClient.HTTP01ChallengeResponse which will trigger the result defined by the following
// Then helper
func (mmHTTP01ChallengeResponse *mAcmeClientMockHTTP01ChallengeResponse) When(token string) *AcmeClientMockHTTP01ChallengeResponseExpectation {
	if mmHTTP01ChallengeResponse.mock.funcHTTP01ChallengeResponse != nil {
		mmHTTP01ChallengeResponse.mock.t.Fatalf("AcmeClientMock.HTTP01ChallengeResponse mock is already set by Set")
	}

	expectation := &AcmeClientMockHTTP01ChallengeResponseExpectation{
		mock:   mmHTTP01ChallengeResponse.mock,
		params: &AcmeClientMockHTTP01ChallengeResponseParams{token},
	}
	mmHTTP01ChallengeResponse.expectations = append(mmHTTP01ChallengeResponse.expectations, expectation)
	return expectation
}

// Then sets up AcmeClient.HTTP01ChallengeResponse return parameters for the expectation previously defined by the When method
func (e *AcmeClientMockHTTP01ChallengeResponseExpectation) Then(s1 string, err error) *AcmeClientMock {
	e.results = &AcmeClientMockHTTP01ChallengeResponseResults{s1, err}
	return e.mock
}

// HTTP01ChallengeResponse implements AcmeClient
func (mmHTTP01ChallengeResponse *AcmeClientMock) HTTP01ChallengeResponse(token string) (s1 string, err error) {
	mm_atomic.AddUint64(&mmHTTP01ChallengeResponse.beforeHTTP01ChallengeResponseCounter, 1)
	defer mm_atomic.AddUint64(&mmHTTP01ChallengeResponse.afterHTTP01ChallengeResponseCounter, 1)

	if mmHTTP01ChallengeResponse.inspectFuncHTTP01ChallengeResponse != nil {
		mmHTTP01ChallengeResponse.inspectFuncHTTP01ChallengeResponse(token)
	}

	mm_params := &AcmeClientMockHTTP01ChallengeResponseParams{token}

	// Record call args
	mmHTTP01ChallengeResponse.HTTP01ChallengeResponseMock.mutex.Lock()
	mmHTTP01ChallengeResponse.HTTP01ChallengeResponseMock.callArgs = append(mmHTTP01ChallengeResponse.HTTP01ChallengeResponseMock.callArgs, mm_params)
	mmHTTP01ChallengeResponse.HTTP01ChallengeResponseMock.mutex.Unlock()

	for _, e := range mmHTTP01ChallengeResponse.HTTP01ChallengeResponseMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.s1, e.results.err
		}
	}

	if mmHTTP01ChallengeResponse.HTTP01ChallengeResponseMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmHTTP01ChallengeResponse.HTTP01ChallengeResponseMock.defaultExpectation.Counter, 1)
		mm_want := mmHTTP01ChallengeResponse.HTTP01ChallengeResponseMock.defaultExpectation.params
		mm_got := AcmeClientMockHTTP01ChallengeResponseParams{token}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmHTTP01ChallengeResponse.t.Errorf("AcmeClientMock.HTTP01ChallengeResponse got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmHTTP01ChallengeResponse.HTTP01ChallengeResponseMock.defaultExpectation.results
		if mm_results == nil {
			mmHTTP01ChallengeResponse.t.Fatal("No results are set for the AcmeClientMock.HTTP01ChallengeResponse")
		}
		return (*mm_results).s1, (*mm_results).err
	}
	if mmHTTP01ChallengeResponse.funcHTTP01ChallengeResponse != nil {
		return mmHTTP01ChallengeResponse.funcHTTP01ChallengeResponse(token)
	}
	mmHTTP01ChallengeResponse.t.Fatalf("Unexpected call to AcmeClientMock.HTTP01ChallengeResponse. %v", token)
	return
}

// HTTP01ChallengeResponseAfterCounter returns a count of finished AcmeClientMock.HTTP01ChallengeResponse invocations
func (mmHTTP01ChallengeResponse *AcmeClientMock) HTTP01ChallengeResponseAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmHTTP01ChallengeResponse.afterHTTP01ChallengeResponseCounter)
}

// HTTP01ChallengeResponseBeforeCounter returns a count of AcmeClientMock.HTTP01ChallengeResponse invocations
func (mmHTTP01ChallengeResponse *AcmeClientMock) HTTP01ChallengeResponseBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmHTTP01ChallengeResponse.beforeHTTP01ChallengeResponseCounter)
}

// Calls returns a list of arguments used in each call to AcmeClientMock.HTTP01ChallengeResponse.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmHTTP01ChallengeResponse *mAcmeClientMockHTTP01ChallengeResponse) Calls() []*AcmeClientMockHTTP01ChallengeResponseParams {
	mmHTTP01ChallengeResponse.mutex.RLock()

	argCopy := make([]*AcmeClientMockHTTP01ChallengeResponseParams, len(mmHTTP01ChallengeResponse.callArgs))
	copy(argCopy, mmHTTP01ChallengeResponse.callArgs)

	mmHTTP01ChallengeResponse.mutex.RUnlock()

	return argCopy
}

// MinimockHTTP01ChallengeResponseDone returns true if the count of the HTTP01ChallengeResponse invocations corresponds
// the number of defined expectations
func (m *AcmeClientMock) MinimockHTTP01ChallengeResponseDone() bool {
	for _, e := range m.HTTP01ChallengeResponseMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.HTTP01ChallengeResponseMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterHTTP01ChallengeResponseCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcHTTP01ChallengeResponse != nil && mm_atomic.LoadUint64(&m.afterHTTP01ChallengeResponseCounter) < 1 {
		return false
	}
	return true
}

// MinimockHTTP01ChallengeResponseInspect logs each unmet expectation
func (m *AcmeClientMock) MinimockHTTP01ChallengeResponseInspect() {
	for _, e := range m.HTTP01ChallengeResponseMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to AcmeClientMock.HTTP01ChallengeResponse with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.HTTP01ChallengeResponseMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterHTTP01ChallengeResponseCounter) < 1 {
		if m.HTTP01ChallengeResponseMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to AcmeClientMock.HTTP01ChallengeResponse")
		} else {
			m.t.Errorf("Expected call to AcmeClientMock.HTTP01ChallengeResponse with params: %#v", *m.HTTP01ChallengeResponseMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcHTTP01ChallengeResponse != nil && mm_atomic.LoadUint64(&m.afterHTTP01ChallengeResponseCounter) < 1 {
		m.t.Error("Expected call to AcmeClientMock.HTTP01ChallengeResponse")
	}
}

type mAcmeClientMockRevokeAuthorization struct {
	mock               *AcmeClientMock
	defaultExpectation *AcmeClientMockRevokeAuthorizationExpectation
	expectations       []*AcmeClientMockRevokeAuthorizationExpectation

	callArgs []*AcmeClientMockRevokeAuthorizationParams
	mutex    sync.RWMutex
}

// AcmeClientMockRevokeAuthorizationExpectation specifies expectation struct of the AcmeClient.RevokeAuthorization
type AcmeClientMockRevokeAuthorizationExpectation struct {
	mock    *AcmeClientMock
	params  *AcmeClientMockRevokeAuthorizationParams
	results *AcmeClientMockRevokeAuthorizationResults
	Counter uint64
}

// AcmeClientMockRevokeAuthorizationParams contains parameters of the AcmeClient.RevokeAuthorization
type AcmeClientMockRevokeAuthorizationParams struct {
	ctx context.Context
	url string
}

// AcmeClientMockRevokeAuthorizationResults contains results of the AcmeClient.RevokeAuthorization
type AcmeClientMockRevokeAuthorizationResults struct {
	err error
}

// Expect sets up expected params for AcmeClient.RevokeAuthorization
func (mmRevokeAuthorization *mAcmeClientMockRevokeAuthorization) Expect(ctx context.Context, url string) *mAcmeClientMockRevokeAuthorization {
	if mmRevokeAuthorization.mock.funcRevokeAuthorization != nil {
		mmRevokeAuthorization.mock.t.Fatalf("AcmeClientMock.RevokeAuthorization mock is already set by Set")
	}

	if mmRevokeAuthorization.defaultExpectation == nil {
		mmRevokeAuthorization.defaultExpectation = &AcmeClientMockRevokeAuthorizationExpectation{}
	}

	mmRevokeAuthorization.defaultExpectation.params = &AcmeClientMockRevokeAuthorizationParams{ctx, url}
	for _, e := range mmRevokeAuthorization.expectations {
		if minimock.Equal(e.params, mmRevokeAuthorization.defaultExpectation.params) {
			mmRevokeAuthorization.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmRevokeAuthorization.defaultExpectation.params)
		}
	}

	return mmRevokeAuthorization
}

// Inspect accepts an inspector function that has same arguments as the AcmeClient.RevokeAuthorization
func (mmRevokeAuthorization *mAcmeClientMockRevokeAuthorization) Inspect(f func(ctx context.Context, url string)) *mAcmeClientMockRevokeAuthorization {
	if mmRevokeAuthorization.mock.inspectFuncRevokeAuthorization != nil {
		mmRevokeAuthorization.mock.t.Fatalf("Inspect function is already set for AcmeClientMock.RevokeAuthorization")
	}

	mmRevokeAuthorization.mock.inspectFuncRevokeAuthorization = f

	return mmRevokeAuthorization
}

// Return sets up results that will be returned by AcmeClient.RevokeAuthorization
func (mmRevokeAuthorization *mAcmeClientMockRevokeAuthorization) Return(err error) *AcmeClientMock {
	if mmRevokeAuthorization.mock.funcRevokeAuthorization != nil {
		mmRevokeAuthorization.mock.t.Fatalf("AcmeClientMock.RevokeAuthorization mock is already set by Set")
	}

	if mmRevokeAuthorization.defaultExpectation == nil {
		mmRevokeAuthorization.defaultExpectation = &AcmeClientMockRevokeAuthorizationExpectation{mock: mmRevokeAuthorization.mock}
	}
	mmRevokeAuthorization.defaultExpectation.results = &AcmeClientMockRevokeAuthorizationResults{err}
	return mmRevokeAuthorization.mock
}

//Set uses given function f to mock the AcmeClient.RevokeAuthorization method
func (mmRevokeAuthorization *mAcmeClientMockRevokeAuthorization) Set(f func(ctx context.Context, url string) (err error)) *AcmeClientMock {
	if mmRevokeAuthorization.defaultExpectation != nil {
		mmRevokeAuthorization.mock.t.Fatalf("Default expectation is already set for the AcmeClient.RevokeAuthorization method")
	}

	if len(mmRevokeAuthorization.expectations) > 0 {
		mmRevokeAuthorization.mock.t.Fatalf("Some expectations are already set for the AcmeClient.RevokeAuthorization method")
	}

	mmRevokeAuthorization.mock.funcRevokeAuthorization = f
	return mmRevokeAuthorization.mock
}

// When sets expectation for the AcmeClient.RevokeAuthorization which will trigger the result defined by the following
// Then helper
func (mmRevokeAuthorization *mAcmeClientMockRevokeAuthorization) When(ctx context.Context, url string) *AcmeClientMockRevokeAuthorizationExpectation {
	if mmRevokeAuthorization.mock.funcRevokeAuthorization != nil {
		mmRevokeAuthorization.mock.t.Fatalf("AcmeClientMock.RevokeAuthorization mock is already set by Set")
	}

	expectation := &AcmeClientMockRevokeAuthorizationExpectation{
		mock:   mmRevokeAuthorization.mock,
		params: &AcmeClientMockRevokeAuthorizationParams{ctx, url},
	}
	mmRevokeAuthorization.expectations = append(mmRevokeAuthorization.expectations, expectation)
	return expectation
}

// Then sets up AcmeClient.RevokeAuthorization return parameters for the expectation previously defined by the When method
func (e *AcmeClientMockRevokeAuthorizationExpectation) Then(err error) *AcmeClientMock {
	e.results = &AcmeClientMockRevokeAuthorizationResults{err}
	return e.mock
}

// RevokeAuthorization implements AcmeClient
func (mmRevokeAuthorization *AcmeClientMock) RevokeAuthorization(ctx context.Context, url string) (err error) {
	mm_atomic.AddUint64(&mmRevokeAuthorization.beforeRevokeAuthorizationCounter, 1)
	defer mm_atomic.AddUint64(&mmRevokeAuthorization.afterRevokeAuthorizationCounter, 1)

	if mmRevokeAuthorization.inspectFuncRevokeAuthorization != nil {
		mmRevokeAuthorization.inspectFuncRevokeAuthorization(ctx, url)
	}

	mm_params := &AcmeClientMockRevokeAuthorizationParams{ctx, url}

	// Record call args
	mmRevokeAuthorization.RevokeAuthorizationMock.mutex.Lock()
	mmRevokeAuthorization.RevokeAuthorizationMock.callArgs = append(mmRevokeAuthorization.RevokeAuthorizationMock.callArgs, mm_params)
	mmRevokeAuthorization.RevokeAuthorizationMock.mutex.Unlock()

	for _, e := range mmRevokeAuthorization.RevokeAuthorizationMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmRevokeAuthorization.RevokeAuthorizationMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmRevokeAuthorization.RevokeAuthorizationMock.defaultExpectation.Counter, 1)
		mm_want := mmRevokeAuthorization.RevokeAuthorizationMock.defaultExpectation.params
		mm_got := AcmeClientMockRevokeAuthorizationParams{ctx, url}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmRevokeAuthorization.t.Errorf("AcmeClientMock.RevokeAuthorization got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmRevokeAuthorization.RevokeAuthorizationMock.defaultExpectation.results
		if mm_results == nil {
			mmRevokeAuthorization.t.Fatal("No results are set for the AcmeClientMock.RevokeAuthorization")
		}
		return (*mm_results).err
	}
	if mmRevokeAuthorization.funcRevokeAuthorization != nil {
		return mmRevokeAuthorization.funcRevokeAuthorization(ctx, url)
	}
	mmRevokeAuthorization.t.Fatalf("Unexpected call to AcmeClientMock.RevokeAuthorization. %v %v", ctx, url)
	return
}

// RevokeAuthorizationAfterCounter returns a count of finished AcmeClientMock.RevokeAuthorization invocations
func (mmRevokeAuthorization *AcmeClientMock) RevokeAuthorizationAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmRevokeAuthorization.afterRevokeAuthorizationCounter)
}

// RevokeAuthorizationBeforeCounter returns a count of AcmeClientMock.RevokeAuthorization invocations
func (mmRevokeAuthorization *AcmeClientMock) RevokeAuthorizationBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmRevokeAuthorization.beforeRevokeAuthorizationCounter)
}

// Calls returns a list of arguments used in each call to AcmeClientMock.RevokeAuthorization.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmRevokeAuthorization *mAcmeClientMockRevokeAuthorization) Calls() []*AcmeClientMockRevokeAuthorizationParams {
	mmRevokeAuthorization.mutex.RLock()

	argCopy := make([]*AcmeClientMockRevokeAuthorizationParams, len(mmRevokeAuthorization.callArgs))
	copy(argCopy, mmRevokeAuthorization.callArgs)

	mmRevokeAuthorization.mutex.RUnlock()

	return argCopy
}

// MinimockRevokeAuthorizationDone returns true if the count of the RevokeAuthorization invocations corresponds
// the number of defined expectations
func (m *AcmeClientMock) MinimockRevokeAuthorizationDone() bool {
	for _, e := range m.RevokeAuthorizationMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.RevokeAuthorizationMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterRevokeAuthorizationCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcRevokeAuthorization != nil && mm_atomic.LoadUint64(&m.afterRevokeAuthorizationCounter) < 1 {
		return false
	}
	return true
}

// MinimockRevokeAuthorizationInspect logs each unmet expectation
func (m *AcmeClientMock) MinimockRevokeAuthorizationInspect() {
	for _, e := range m.RevokeAuthorizationMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to AcmeClientMock.RevokeAuthorization with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.RevokeAuthorizationMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterRevokeAuthorizationCounter) < 1 {
		if m.RevokeAuthorizationMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to AcmeClientMock.RevokeAuthorization")
		} else {
			m.t.Errorf("Expected call to AcmeClientMock.RevokeAuthorization with params: %#v", *m.RevokeAuthorizationMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcRevokeAuthorization != nil && mm_atomic.LoadUint64(&m.afterRevokeAuthorizationCounter) < 1 {
		m.t.Error("Expected call to AcmeClientMock.RevokeAuthorization")
	}
}

type mAcmeClientMockTLSALPN01ChallengeCert struct {
	mock               *AcmeClientMock
	defaultExpectation *AcmeClientMockTLSALPN01ChallengeCertExpectation
	expectations       []*AcmeClientMockTLSALPN01ChallengeCertExpectation

	callArgs []*AcmeClientMockTLSALPN01ChallengeCertParams
	mutex    sync.RWMutex
}

// AcmeClientMockTLSALPN01ChallengeCertExpectation specifies expectation struct of the AcmeClient.TLSALPN01ChallengeCert
type AcmeClientMockTLSALPN01ChallengeCertExpectation struct {
	mock    *AcmeClientMock
	params  *AcmeClientMockTLSALPN01ChallengeCertParams
	results *AcmeClientMockTLSALPN01ChallengeCertResults
	Counter uint64
}

// AcmeClientMockTLSALPN01ChallengeCertParams contains parameters of the AcmeClient.TLSALPN01ChallengeCert
type AcmeClientMockTLSALPN01ChallengeCertParams struct {
	token  string
	domain string
	opt    []acme.CertOption
}

// AcmeClientMockTLSALPN01ChallengeCertResults contains results of the AcmeClient.TLSALPN01ChallengeCert
type AcmeClientMockTLSALPN01ChallengeCertResults struct {
	cert tls.Certificate
	err  error
}

// Expect sets up expected params for AcmeClient.TLSALPN01ChallengeCert
func (mmTLSALPN01ChallengeCert *mAcmeClientMockTLSALPN01ChallengeCert) Expect(token string, domain string, opt ...acme.CertOption) *mAcmeClientMockTLSALPN01ChallengeCert {
	if mmTLSALPN01ChallengeCert.mock.funcTLSALPN01ChallengeCert != nil {
		mmTLSALPN01ChallengeCert.mock.t.Fatalf("AcmeClientMock.TLSALPN01ChallengeCert mock is already set by Set")
	}

	if mmTLSALPN01ChallengeCert.defaultExpectation == nil {
		mmTLSALPN01ChallengeCert.defaultExpectation = &AcmeClientMockTLSALPN01ChallengeCertExpectation{}
	}

	mmTLSALPN01ChallengeCert.defaultExpectation.params = &AcmeClientMockTLSALPN01ChallengeCertParams{token, domain, opt}
	for _, e := range mmTLSALPN01ChallengeCert.expectations {
		if minimock.Equal(e.params, mmTLSALPN01ChallengeCert.defaultExpectation.params) {
			mmTLSALPN01ChallengeCert.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmTLSALPN01ChallengeCert.defaultExpectation.params)
		}
	}

	return mmTLSALPN01ChallengeCert
}

// Inspect accepts an inspector function that has same arguments as the AcmeClient.TLSALPN01ChallengeCert
func (mmTLSALPN01ChallengeCert *mAcmeClientMockTLSALPN01ChallengeCert) Inspect(f func(token string, domain string, opt ...acme.CertOption)) *mAcmeClientMockTLSALPN01ChallengeCert {
	if mmTLSALPN01ChallengeCert.mock.inspectFuncTLSALPN01ChallengeCert != nil {
		mmTLSALPN01ChallengeCert.mock.t.Fatalf("Inspect function is already set for AcmeClientMock.TLSALPN01ChallengeCert")
	}

	mmTLSALPN01ChallengeCert.mock.inspectFuncTLSALPN01ChallengeCert = f

	return mmTLSALPN01ChallengeCert
}

// Return sets up results that will be returned by AcmeClient.TLSALPN01ChallengeCert
func (mmTLSALPN01ChallengeCert *mAcmeClientMockTLSALPN01ChallengeCert) Return(cert tls.Certificate, err error) *AcmeClientMock {
	if mmTLSALPN01ChallengeCert.mock.funcTLSALPN01ChallengeCert != nil {
		mmTLSALPN01ChallengeCert.mock.t.Fatalf("AcmeClientMock.TLSALPN01ChallengeCert mock is already set by Set")
	}

	if mmTLSALPN01ChallengeCert.defaultExpectation == nil {
		mmTLSALPN01ChallengeCert.defaultExpectation = &AcmeClientMockTLSALPN01ChallengeCertExpectation{mock: mmTLSALPN01ChallengeCert.mock}
	}
	mmTLSALPN01ChallengeCert.defaultExpectation.results = &AcmeClientMockTLSALPN01ChallengeCertResults{cert, err}
	return mmTLSALPN01ChallengeCert.mock
}

//Set uses given function f to mock the AcmeClient.TLSALPN01ChallengeCert method
func (mmTLSALPN01ChallengeCert *mAcmeClientMockTLSALPN01ChallengeCert) Set(f func(token string, domain string, opt ...acme.CertOption) (cert tls.Certificate, err error)) *AcmeClientMock {
	if mmTLSALPN01ChallengeCert.defaultExpectation != nil {
		mmTLSALPN01ChallengeCert.mock.t.Fatalf("Default expectation is already set for the AcmeClient.TLSALPN01ChallengeCert method")
	}

	if len(mmTLSALPN01ChallengeCert.expectations) > 0 {
		mmTLSALPN01ChallengeCert.mock.t.Fatalf("Some expectations are already set for the AcmeClient.TLSALPN01ChallengeCert method")
	}

	mmTLSALPN01ChallengeCert.mock.funcTLSALPN01ChallengeCert = f
	return mmTLSALPN01ChallengeCert.mock
}

// When sets expectation for the AcmeClient.TLSALPN01ChallengeCert which will trigger the result defined by the following
// Then helper
func (mmTLSALPN01ChallengeCert *mAcmeClientMockTLSALPN01ChallengeCert) When(token string, domain string, opt ...acme.CertOption) *AcmeClientMockTLSALPN01ChallengeCertExpectation {
	if mmTLSALPN01ChallengeCert.mock.funcTLSALPN01ChallengeCert != nil {
		mmTLSALPN01ChallengeCert.mock.t.Fatalf("AcmeClientMock.TLSALPN01ChallengeCert mock is already set by Set")
	}

	expectation := &AcmeClientMockTLSALPN01ChallengeCertExpectation{
		mock:   mmTLSALPN01ChallengeCert.mock,
		params: &AcmeClientMockTLSALPN01ChallengeCertParams{token, domain, opt},
	}
	mmTLSALPN01ChallengeCert.expectations = append(mmTLSALPN01ChallengeCert.expectations, expectation)
	return expectation
}

// Then sets up AcmeClient.TLSALPN01ChallengeCert return parameters for the expectation previously defined by the When method
func (e *AcmeClientMockTLSALPN01ChallengeCertExpectation) Then(cert tls.Certificate, err error) *AcmeClientMock {
	e.results = &AcmeClientMockTLSALPN01ChallengeCertResults{cert, err}
	return e.mock
}

// TLSALPN01ChallengeCert implements AcmeClient
func (mmTLSALPN01ChallengeCert *AcmeClientMock) TLSALPN01ChallengeCert(token string, domain string, opt ...acme.CertOption) (cert tls.Certificate, err error) {
	mm_atomic.AddUint64(&mmTLSALPN01ChallengeCert.beforeTLSALPN01ChallengeCertCounter, 1)
	defer mm_atomic.AddUint64(&mmTLSALPN01ChallengeCert.afterTLSALPN01ChallengeCertCounter, 1)

	if mmTLSALPN01ChallengeCert.inspectFuncTLSALPN01ChallengeCert != nil {
		mmTLSALPN01ChallengeCert.inspectFuncTLSALPN01ChallengeCert(token, domain, opt...)
	}

	mm_params := &AcmeClientMockTLSALPN01ChallengeCertParams{token, domain, opt}

	// Record call args
	mmTLSALPN01ChallengeCert.TLSALPN01ChallengeCertMock.mutex.Lock()
	mmTLSALPN01ChallengeCert.TLSALPN01ChallengeCertMock.callArgs = append(mmTLSALPN01ChallengeCert.TLSALPN01ChallengeCertMock.callArgs, mm_params)
	mmTLSALPN01ChallengeCert.TLSALPN01ChallengeCertMock.mutex.Unlock()

	for _, e := range mmTLSALPN01ChallengeCert.TLSALPN01ChallengeCertMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.cert, e.results.err
		}
	}

	if mmTLSALPN01ChallengeCert.TLSALPN01ChallengeCertMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmTLSALPN01ChallengeCert.TLSALPN01ChallengeCertMock.defaultExpectation.Counter, 1)
		mm_want := mmTLSALPN01ChallengeCert.TLSALPN01ChallengeCertMock.defaultExpectation.params
		mm_got := AcmeClientMockTLSALPN01ChallengeCertParams{token, domain, opt}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmTLSALPN01ChallengeCert.t.Errorf("AcmeClientMock.TLSALPN01ChallengeCert got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmTLSALPN01ChallengeCert.TLSALPN01ChallengeCertMock.defaultExpectation.results
		if mm_results == nil {
			mmTLSALPN01ChallengeCert.t.Fatal("No results are set for the AcmeClientMock.TLSALPN01ChallengeCert")
		}
		return (*mm_results).cert, (*mm_results).err
	}
	if mmTLSALPN01ChallengeCert.funcTLSALPN01ChallengeCert != nil {
		return mmTLSALPN01ChallengeCert.funcTLSALPN01ChallengeCert(token, domain, opt...)
	}
	mmTLSALPN01ChallengeCert.t.Fatalf("Unexpected call to AcmeClientMock.TLSALPN01ChallengeCert. %v %v %v", token, domain, opt)
	return
}

// TLSALPN01ChallengeCertAfterCounter returns a count of finished AcmeClientMock.TLSALPN01ChallengeCert invocations
func (mmTLSALPN01ChallengeCert *AcmeClientMock) TLSALPN01ChallengeCertAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmTLSALPN01ChallengeCert.afterTLSALPN01ChallengeCertCounter)
}

// TLSALPN01ChallengeCertBeforeCounter returns a count of AcmeClientMock.TLSALPN01ChallengeCert invocations
func (mmTLSALPN01ChallengeCert *AcmeClientMock) TLSALPN01ChallengeCertBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmTLSALPN01ChallengeCert.beforeTLSALPN01ChallengeCertCounter)
}

// Calls returns a list of arguments used in each call to AcmeClientMock.TLSALPN01ChallengeCert.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmTLSALPN01ChallengeCert *mAcmeClientMockTLSALPN01ChallengeCert) Calls() []*AcmeClientMockTLSALPN01ChallengeCertParams {
	mmTLSALPN01ChallengeCert.mutex.RLock()

	argCopy := make([]*AcmeClientMockTLSALPN01ChallengeCertParams, len(mmTLSALPN01ChallengeCert.callArgs))
	copy(argCopy, mmTLSALPN01ChallengeCert.callArgs)

	mmTLSALPN01ChallengeCert.mutex.RUnlock()

	return argCopy
}

// MinimockTLSALPN01ChallengeCertDone returns true if the count of the TLSALPN01ChallengeCert invocations corresponds
// the number of defined expectations
func (m *AcmeClientMock) MinimockTLSALPN01ChallengeCertDone() bool {
	for _, e := range m.TLSALPN01ChallengeCertMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.TLSALPN01ChallengeCertMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterTLSALPN01ChallengeCertCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcTLSALPN01ChallengeCert != nil && mm_atomic.LoadUint64(&m.afterTLSALPN01ChallengeCertCounter) < 1 {
		return false
	}
	return true
}

// MinimockTLSALPN01ChallengeCertInspect logs each unmet expectation
func (m *AcmeClientMock) MinimockTLSALPN01ChallengeCertInspect() {
	for _, e := range m.TLSALPN01ChallengeCertMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to AcmeClientMock.TLSALPN01ChallengeCert with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.TLSALPN01ChallengeCertMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterTLSALPN01ChallengeCertCounter) < 1 {
		if m.TLSALPN01ChallengeCertMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to AcmeClientMock.TLSALPN01ChallengeCert")
		} else {
			m.t.Errorf("Expected call to AcmeClientMock.TLSALPN01ChallengeCert with params: %#v", *m.TLSALPN01ChallengeCertMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcTLSALPN01ChallengeCert != nil && mm_atomic.LoadUint64(&m.afterTLSALPN01ChallengeCertCounter) < 1 {
		m.t.Error("Expected call to AcmeClientMock.TLSALPN01ChallengeCert")
	}
}

type mAcmeClientMockWaitAuthorization struct {
	mock               *AcmeClientMock
	defaultExpectation *AcmeClientMockWaitAuthorizationExpectation
	expectations       []*AcmeClientMockWaitAuthorizationExpectation

	callArgs []*AcmeClientMockWaitAuthorizationParams
	mutex    sync.RWMutex
}

// AcmeClientMockWaitAuthorizationExpectation specifies expectation struct of the AcmeClient.WaitAuthorization
type AcmeClientMockWaitAuthorizationExpectation struct {
	mock    *AcmeClientMock
	params  *AcmeClientMockWaitAuthorizationParams
	results *AcmeClientMockWaitAuthorizationResults
	Counter uint64
}

// AcmeClientMockWaitAuthorizationParams contains parameters of the AcmeClient.WaitAuthorization
type AcmeClientMockWaitAuthorizationParams struct {
	ctx context.Context
	url string
}

// AcmeClientMockWaitAuthorizationResults contains results of the AcmeClient.WaitAuthorization
type AcmeClientMockWaitAuthorizationResults struct {
	ap1 *acme.Authorization
	err error
}

// Expect sets up expected params for AcmeClient.WaitAuthorization
func (mmWaitAuthorization *mAcmeClientMockWaitAuthorization) Expect(ctx context.Context, url string) *mAcmeClientMockWaitAuthorization {
	if mmWaitAuthorization.mock.funcWaitAuthorization != nil {
		mmWaitAuthorization.mock.t.Fatalf("AcmeClientMock.WaitAuthorization mock is already set by Set")
	}

	if mmWaitAuthorization.defaultExpectation == nil {
		mmWaitAuthorization.defaultExpectation = &AcmeClientMockWaitAuthorizationExpectation{}
	}

	mmWaitAuthorization.defaultExpectation.params = &AcmeClientMockWaitAuthorizationParams{ctx, url}
	for _, e := range mmWaitAuthorization.expectations {
		if minimock.Equal(e.params, mmWaitAuthorization.defaultExpectation.params) {
			mmWaitAuthorization.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmWaitAuthorization.defaultExpectation.params)
		}
	}

	return mmWaitAuthorization
}

// Inspect accepts an inspector function that has same arguments as the AcmeClient.WaitAuthorization
func (mmWaitAuthorization *mAcmeClientMockWaitAuthorization) Inspect(f func(ctx context.Context, url string)) *mAcmeClientMockWaitAuthorization {
	if mmWaitAuthorization.mock.inspectFuncWaitAuthorization != nil {
		mmWaitAuthorization.mock.t.Fatalf("Inspect function is already set for AcmeClientMock.WaitAuthorization")
	}

	mmWaitAuthorization.mock.inspectFuncWaitAuthorization = f

	return mmWaitAuthorization
}

// Return sets up results that will be returned by AcmeClient.WaitAuthorization
func (mmWaitAuthorization *mAcmeClientMockWaitAuthorization) Return(ap1 *acme.Authorization, err error) *AcmeClientMock {
	if mmWaitAuthorization.mock.funcWaitAuthorization != nil {
		mmWaitAuthorization.mock.t.Fatalf("AcmeClientMock.WaitAuthorization mock is already set by Set")
	}

	if mmWaitAuthorization.defaultExpectation == nil {
		mmWaitAuthorization.defaultExpectation = &AcmeClientMockWaitAuthorizationExpectation{mock: mmWaitAuthorization.mock}
	}
	mmWaitAuthorization.defaultExpectation.results = &AcmeClientMockWaitAuthorizationResults{ap1, err}
	return mmWaitAuthorization.mock
}

//Set uses given function f to mock the AcmeClient.WaitAuthorization method
func (mmWaitAuthorization *mAcmeClientMockWaitAuthorization) Set(f func(ctx context.Context, url string) (ap1 *acme.Authorization, err error)) *AcmeClientMock {
	if mmWaitAuthorization.defaultExpectation != nil {
		mmWaitAuthorization.mock.t.Fatalf("Default expectation is already set for the AcmeClient.WaitAuthorization method")
	}

	if len(mmWaitAuthorization.expectations) > 0 {
		mmWaitAuthorization.mock.t.Fatalf("Some expectations are already set for the AcmeClient.WaitAuthorization method")
	}

	mmWaitAuthorization.mock.funcWaitAuthorization = f
	return mmWaitAuthorization.mock
}

// When sets expectation for the AcmeClient.WaitAuthorization which will trigger the result defined by the following
// Then helper
func (mmWaitAuthorization *mAcmeClientMockWaitAuthorization) When(ctx context.Context, url string) *AcmeClientMockWaitAuthorizationExpectation {
	if mmWaitAuthorization.mock.funcWaitAuthorization != nil {
		mmWaitAuthorization.mock.t.Fatalf("AcmeClientMock.WaitAuthorization mock is already set by Set")
	}

	expectation := &AcmeClientMockWaitAuthorizationExpectation{
		mock:   mmWaitAuthorization.mock,
		params: &AcmeClientMockWaitAuthorizationParams{ctx, url},
	}
	mmWaitAuthorization.expectations = append(mmWaitAuthorization.expectations, expectation)
	return expectation
}

// Then sets up AcmeClient.WaitAuthorization return parameters for the expectation previously defined by the When method
func (e *AcmeClientMockWaitAuthorizationExpectation) Then(ap1 *acme.Authorization, err error) *AcmeClientMock {
	e.results = &AcmeClientMockWaitAuthorizationResults{ap1, err}
	return e.mock
}

// WaitAuthorization implements AcmeClient
func (mmWaitAuthorization *AcmeClientMock) WaitAuthorization(ctx context.Context, url string) (ap1 *acme.Authorization, err error) {
	mm_atomic.AddUint64(&mmWaitAuthorization.beforeWaitAuthorizationCounter, 1)
	defer mm_atomic.AddUint64(&mmWaitAuthorization.afterWaitAuthorizationCounter, 1)

	if mmWaitAuthorization.inspectFuncWaitAuthorization != nil {
		mmWaitAuthorization.inspectFuncWaitAuthorization(ctx, url)
	}

	mm_params := &AcmeClientMockWaitAuthorizationParams{ctx, url}

	// Record call args
	mmWaitAuthorization.WaitAuthorizationMock.mutex.Lock()
	mmWaitAuthorization.WaitAuthorizationMock.callArgs = append(mmWaitAuthorization.WaitAuthorizationMock.callArgs, mm_params)
	mmWaitAuthorization.WaitAuthorizationMock.mutex.Unlock()

	for _, e := range mmWaitAuthorization.WaitAuthorizationMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.ap1, e.results.err
		}
	}

	if mmWaitAuthorization.WaitAuthorizationMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmWaitAuthorization.WaitAuthorizationMock.defaultExpectation.Counter, 1)
		mm_want := mmWaitAuthorization.WaitAuthorizationMock.defaultExpectation.params
		mm_got := AcmeClientMockWaitAuthorizationParams{ctx, url}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmWaitAuthorization.t.Errorf("AcmeClientMock.WaitAuthorization got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmWaitAuthorization.WaitAuthorizationMock.defaultExpectation.results
		if mm_results == nil {
			mmWaitAuthorization.t.Fatal("No results are set for the AcmeClientMock.WaitAuthorization")
		}
		return (*mm_results).ap1, (*mm_results).err
	}
	if mmWaitAuthorization.funcWaitAuthorization != nil {
		return mmWaitAuthorization.funcWaitAuthorization(ctx, url)
	}
	mmWaitAuthorization.t.Fatalf("Unexpected call to AcmeClientMock.WaitAuthorization. %v %v", ctx, url)
	return
}

// WaitAuthorizationAfterCounter returns a count of finished AcmeClientMock.WaitAuthorization invocations
func (mmWaitAuthorization *AcmeClientMock) WaitAuthorizationAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmWaitAuthorization.afterWaitAuthorizationCounter)
}

// WaitAuthorizationBeforeCounter returns a count of AcmeClientMock.WaitAuthorization invocations
func (mmWaitAuthorization *AcmeClientMock) WaitAuthorizationBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmWaitAuthorization.beforeWaitAuthorizationCounter)
}

// Calls returns a list of arguments used in each call to AcmeClientMock.WaitAuthorization.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmWaitAuthorization *mAcmeClientMockWaitAuthorization) Calls() []*AcmeClientMockWaitAuthorizationParams {
	mmWaitAuthorization.mutex.RLock()

	argCopy := make([]*AcmeClientMockWaitAuthorizationParams, len(mmWaitAuthorization.callArgs))
	copy(argCopy, mmWaitAuthorization.callArgs)

	mmWaitAuthorization.mutex.RUnlock()

	return argCopy
}

// MinimockWaitAuthorizationDone returns true if the count of the WaitAuthorization invocations corresponds
// the number of defined expectations
func (m *AcmeClientMock) MinimockWaitAuthorizationDone() bool {
	for _, e := range m.WaitAuthorizationMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.WaitAuthorizationMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterWaitAuthorizationCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcWaitAuthorization != nil && mm_atomic.LoadUint64(&m.afterWaitAuthorizationCounter) < 1 {
		return false
	}
	return true
}

// MinimockWaitAuthorizationInspect logs each unmet expectation
func (m *AcmeClientMock) MinimockWaitAuthorizationInspect() {
	for _, e := range m.WaitAuthorizationMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to AcmeClientMock.WaitAuthorization with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.WaitAuthorizationMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterWaitAuthorizationCounter) < 1 {
		if m.WaitAuthorizationMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to AcmeClientMock.WaitAuthorization")
		} else {
			m.t.Errorf("Expected call to AcmeClientMock.WaitAuthorization with params: %#v", *m.WaitAuthorizationMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcWaitAuthorization != nil && mm_atomic.LoadUint64(&m.afterWaitAuthorizationCounter) < 1 {
		m.t.Error("Expected call to AcmeClientMock.WaitAuthorization")
	}
}

type mAcmeClientMockWaitOrder struct {
	mock               *AcmeClientMock
	defaultExpectation *AcmeClientMockWaitOrderExpectation
	expectations       []*AcmeClientMockWaitOrderExpectation

	callArgs []*AcmeClientMockWaitOrderParams
	mutex    sync.RWMutex
}

// AcmeClientMockWaitOrderExpectation specifies expectation struct of the AcmeClient.WaitOrder
type AcmeClientMockWaitOrderExpectation struct {
	mock    *AcmeClientMock
	params  *AcmeClientMockWaitOrderParams
	results *AcmeClientMockWaitOrderResults
	Counter uint64
}

// AcmeClientMockWaitOrderParams contains parameters of the AcmeClient.WaitOrder
type AcmeClientMockWaitOrderParams struct {
	ctx context.Context
	url string
}

// AcmeClientMockWaitOrderResults contains results of the AcmeClient.WaitOrder
type AcmeClientMockWaitOrderResults struct {
	op1 *acme.Order
	err error
}

// Expect sets up expected params for AcmeClient.WaitOrder
func (mmWaitOrder *mAcmeClientMockWaitOrder) Expect(ctx context.Context, url string) *mAcmeClientMockWaitOrder {
	if mmWaitOrder.mock.funcWaitOrder != nil {
		mmWaitOrder.mock.t.Fatalf("AcmeClientMock.WaitOrder mock is already set by Set")
	}

	if mmWaitOrder.defaultExpectation == nil {
		mmWaitOrder.defaultExpectation = &AcmeClientMockWaitOrderExpectation{}
	}

	mmWaitOrder.defaultExpectation.params = &AcmeClientMockWaitOrderParams{ctx, url}
	for _, e := range mmWaitOrder.expectations {
		if minimock.Equal(e.params, mmWaitOrder.defaultExpectation.params) {
			mmWaitOrder.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmWaitOrder.defaultExpectation.params)
		}
	}

	return mmWaitOrder
}

// Inspect accepts an inspector function that has same arguments as the AcmeClient.WaitOrder
func (mmWaitOrder *mAcmeClientMockWaitOrder) Inspect(f func(ctx context.Context, url string)) *mAcmeClientMockWaitOrder {
	if mmWaitOrder.mock.inspectFuncWaitOrder != nil {
		mmWaitOrder.mock.t.Fatalf("Inspect function is already set for AcmeClientMock.WaitOrder")
	}

	mmWaitOrder.mock.inspectFuncWaitOrder = f

	return mmWaitOrder
}

// Return sets up results that will be returned by AcmeClient.WaitOrder
func (mmWaitOrder *mAcmeClientMockWaitOrder) Return(op1 *acme.Order, err error) *AcmeClientMock {
	if mmWaitOrder.mock.funcWaitOrder != nil {
		mmWaitOrder.mock.t.Fatalf("AcmeClientMock.WaitOrder mock is already set by Set")
	}

	if mmWaitOrder.defaultExpectation == nil {
		mmWaitOrder.defaultExpectation = &AcmeClientMockWaitOrderExpectation{mock: mmWaitOrder.mock}
	}
	mmWaitOrder.defaultExpectation.results = &AcmeClientMockWaitOrderResults{op1, err}
	return mmWaitOrder.mock
}

//Set uses given function f to mock the AcmeClient.WaitOrder method
func (mmWaitOrder *mAcmeClientMockWaitOrder) Set(f func(ctx context.Context, url string) (op1 *acme.Order, err error)) *AcmeClientMock {
	if mmWaitOrder.defaultExpectation != nil {
		mmWaitOrder.mock.t.Fatalf("Default expectation is already set for the AcmeClient.WaitOrder method")
	}

	if len(mmWaitOrder.expectations) > 0 {
		mmWaitOrder.mock.t.Fatalf("Some expectations are already set for the AcmeClient.WaitOrder method")
	}

	mmWaitOrder.mock.funcWaitOrder = f
	return mmWaitOrder.mock
}

// When sets expectation for the AcmeClient.WaitOrder which will trigger the result defined by the following
// Then helper
func (mmWaitOrder *mAcmeClientMockWaitOrder) When(ctx context.Context, url string) *AcmeClientMockWaitOrderExpectation {
	if mmWaitOrder.mock.funcWaitOrder != nil {
		mmWaitOrder.mock.t.Fatalf("AcmeClientMock.WaitOrder mock is already set by Set")
	}

	expectation := &AcmeClientMockWaitOrderExpectation{
		mock:   mmWaitOrder.mock,
		params: &AcmeClientMockWaitOrderParams{ctx, url},
	}
	mmWaitOrder.expectations = append(mmWaitOrder.expectations, expectation)
	return expectation
}

// Then sets up AcmeClient.WaitOrder return parameters for the expectation previously defined by the When method
func (e *AcmeClientMockWaitOrderExpectation) Then(op1 *acme.Order, err error) *AcmeClientMock {
	e.results = &AcmeClientMockWaitOrderResults{op1, err}
	return e.mock
}

// WaitOrder implements AcmeClient
func (mmWaitOrder *AcmeClientMock) WaitOrder(ctx context.Context, url string) (op1 *acme.Order, err error) {
	mm_atomic.AddUint64(&mmWaitOrder.beforeWaitOrderCounter, 1)
	defer mm_atomic.AddUint64(&mmWaitOrder.afterWaitOrderCounter, 1)

	if mmWaitOrder.inspectFuncWaitOrder != nil {
		mmWaitOrder.inspectFuncWaitOrder(ctx, url)
	}

	mm_params := &AcmeClientMockWaitOrderParams{ctx, url}

	// Record call args
	mmWaitOrder.WaitOrderMock.mutex.Lock()
	mmWaitOrder.WaitOrderMock.callArgs = append(mmWaitOrder.WaitOrderMock.callArgs, mm_params)
	mmWaitOrder.WaitOrderMock.mutex.Unlock()

	for _, e := range mmWaitOrder.WaitOrderMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.op1, e.results.err
		}
	}

	if mmWaitOrder.WaitOrderMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmWaitOrder.WaitOrderMock.defaultExpectation.Counter, 1)
		mm_want := mmWaitOrder.WaitOrderMock.defaultExpectation.params
		mm_got := AcmeClientMockWaitOrderParams{ctx, url}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmWaitOrder.t.Errorf("AcmeClientMock.WaitOrder got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmWaitOrder.WaitOrderMock.defaultExpectation.results
		if mm_results == nil {
			mmWaitOrder.t.Fatal("No results are set for the AcmeClientMock.WaitOrder")
		}
		return (*mm_results).op1, (*mm_results).err
	}
	if mmWaitOrder.funcWaitOrder != nil {
		return mmWaitOrder.funcWaitOrder(ctx, url)
	}
	mmWaitOrder.t.Fatalf("Unexpected call to AcmeClientMock.WaitOrder. %v %v", ctx, url)
	return
}

// WaitOrderAfterCounter returns a count of finished AcmeClientMock.WaitOrder invocations
func (mmWaitOrder *AcmeClientMock) WaitOrderAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmWaitOrder.afterWaitOrderCounter)
}

// WaitOrderBeforeCounter returns a count of AcmeClientMock.WaitOrder invocations
func (mmWaitOrder *AcmeClientMock) WaitOrderBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmWaitOrder.beforeWaitOrderCounter)
}

// Calls returns a list of arguments used in each call to AcmeClientMock.WaitOrder.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmWaitOrder *mAcmeClientMockWaitOrder) Calls() []*AcmeClientMockWaitOrderParams {
	mmWaitOrder.mutex.RLock()

	argCopy := make([]*AcmeClientMockWaitOrderParams, len(mmWaitOrder.callArgs))
	copy(argCopy, mmWaitOrder.callArgs)

	mmWaitOrder.mutex.RUnlock()

	return argCopy
}

// MinimockWaitOrderDone returns true if the count of the WaitOrder invocations corresponds
// the number of defined expectations
func (m *AcmeClientMock) MinimockWaitOrderDone() bool {
	for _, e := range m.WaitOrderMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.WaitOrderMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterWaitOrderCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcWaitOrder != nil && mm_atomic.LoadUint64(&m.afterWaitOrderCounter) < 1 {
		return false
	}
	return true
}

// MinimockWaitOrderInspect logs each unmet expectation
func (m *AcmeClientMock) MinimockWaitOrderInspect() {
	for _, e := range m.WaitOrderMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to AcmeClientMock.WaitOrder with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.WaitOrderMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterWaitOrderCounter) < 1 {
		if m.WaitOrderMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to AcmeClientMock.WaitOrder")
		} else {
			m.t.Errorf("Expected call to AcmeClientMock.WaitOrder with params: %#v", *m.WaitOrderMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcWaitOrder != nil && mm_atomic.LoadUint64(&m.afterWaitOrderCounter) < 1 {
		m.t.Error("Expected call to AcmeClientMock.WaitOrder")
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *AcmeClientMock) MinimockFinish() {
	if !m.minimockDone() {
		m.MinimockAcceptInspect()

		m.MinimockAuthorizeOrderInspect()

		m.MinimockCreateOrderCertInspect()

		m.MinimockGetAuthorizationInspect()

		m.MinimockHTTP01ChallengeResponseInspect()

		m.MinimockRevokeAuthorizationInspect()

		m.MinimockTLSALPN01ChallengeCertInspect()

		m.MinimockWaitAuthorizationInspect()

		m.MinimockWaitOrderInspect()
		m.t.FailNow()
	}
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *AcmeClientMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *AcmeClientMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockAcceptDone() &&
		m.MinimockAuthorizeOrderDone() &&
		m.MinimockCreateOrderCertDone() &&
		m.MinimockGetAuthorizationDone() &&
		m.MinimockHTTP01ChallengeResponseDone() &&
		m.MinimockRevokeAuthorizationDone() &&
		m.MinimockTLSALPN01ChallengeCertDone() &&
		m.MinimockWaitAuthorizationDone() &&
		m.MinimockWaitOrderDone()
}
